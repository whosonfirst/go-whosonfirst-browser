{{ define "create" }}
{{ template "browser_header" . }}

      <script src="{{ JoinPath .Paths.URIPrefix "/javascript/whosonfirst.browser.api.js" }}"></script>
      <script src="{{ JoinPath .Paths.URIPrefix "/javascript/whosonfirst.browser.leaflet.js" }}"></script>
      <script src="{{ JoinPath .Paths.URIPrefix "/javascript/whosonfirst.webcomponent.existentialflag.js" }}"></script>
      <script src="{{ JoinPath .Paths.URIPrefix "/javascript/whosonfirst.webcomponent.placetype.js" }}"></script>                  
      <script src="{{ JoinPath .Paths.URIPrefix "/javascript/whosonfirst.browser.create.js" }}"></script>
      <script src="{{ JoinPath .Paths.URIPrefix "/javascript/whosonfirst.browser.create.init.js" }}"></script>	 
      
      <link rel="stylesheet" href="{{ JoinPath .Paths.URIPrefix "/css/whosonfirst.browser.edit.css" }}" />

      <div class="container" id="create-feature">

	  <div id="feedback"></div>	  
	  <div class="grid-view">
	      
	      <div id="map" class="row" data-map-provider="{{ .MapProvider }}" data-enable-draw="true"></div>
	      
	      <div id="edit">		 
		  		  
		  <form class="form" class="row g-3" id="wof-properties-form">
		      
		      <!--
			  See the way everything is a textarea? That's the default and allows arbitrary
			   JSON to be written if necessary. Eventually the idea is to write and use web
			   components to transform these textareas in to custom elements.
		      -->
		      
		      <div class="col-auto wof-property-block">
			  <label for="wof:name" >wof:name</label>
			  <textarea class="form-control-plaintext wof-property wof-property-string" id="wof:name"></textarea>
		      </div>
		      
		      <div class="col-auto wof-property-block">
			  <label for="wof:placetype" class="form-label">wof:placetype</label>
			  <whosonfirst-placetype data-id="wof:placetype">			  
			      <textarea class="form-control-plaintext wof-property wof-property-placetype" id="wof:placetype"></textarea>
			  </whosonfirst-placetype>
		      </div>
			  
		      <div class="col-auto wof-property-block wof-property-optional-x">
			  <label for="edtf:inception" >edtf:inception</label>
			  <whosonfirst-edtf data-id="edtf:inception">			  			  
			      <textarea class="form-control-plaintext wof-property wof-property-edtf" id="edtf:inception"></textarea>
			  </whosonfirst-edtf>
		      </div>
		      
		      <div class="col-auto wof-property-block wof-property-optional-x">
			  <label for="edtf:cessation" >edtf:cessation</label>
			  <whosonfirst-edtf data-id="edtf:inception">			  			  			  
			      <textarea class="form-control-plaintext wof-property wof-property-edtf" id="edtf:cessation"></textarea>
			  </whosonfirst>
		      </div>
		      
		      <div class="col-auto wof-property-block">
			  <label for="wof:repo" >wof:repo</label>
			  <textarea class="form-control-plaintext wof-property wof-property-repo" id="wof:repo"></textarea>
		      </div>
		      
		      <div class="col-auto wof-property-block wof-property-optional-x">
			  <label for="mz:is_current" >mz:is_current</label>
			  <whosonfirst-existential-flag data-id="mz:is_current">
			      <textarea class="form-control-plaintext wof-property wof-property-existential" id="mz:is_current"></textarea>
			  </whosonfirst-existential-flag>
		      </div>

		      <div class="col-auto wof-property-block">
			  <label for="src:geom" >src:geom</label>
			  <textarea class="form-control-plaintext wof-property wof-property-string" id="src:geom"></textarea>
		      </div>
		      
		      {{ range $idx, $pr := .CustomProperties }}
		      <!-- Note the data-id attribute on the wrapper div; that's to account for the inability to generate template-based tags (below) -->
		      <div class="col-auto wof-property-block wof-property-custom-element{{ if not $pr.Required }} wof-property-optional{{ end }}" id="{{ $pr.Name }}-wrapper" data-id="{{ $pr.Name}}" data-custom-element="{{ $pr.CustomElement }}">
			  <label for="{{ $pr.Name }}" >{{ $pr.Name }}</label>
			  <!--
			  See the way we're assiging a conditional wof-property-custom-element and data-custom-element
			  class? That's to account for the fact that there is no way to make Go templates generate markup
			  derived from template variables. When you try that markup gets escaped. Instead we're going to
			  have to investigate using custom JS code to rewrite the DOM and invoke the custom web components...
			  -->
			  <textarea class="form-control-plaintext wof-property wof-property-{{ $pr.Type }}{{ if ne $pr.CustomElement "" }} wof-property-custom-element{{ end }}" id="{{ $pr.Name }}"{{ if ne $pr.CustomElement "" }} data-custom-element="{{ $pr.CustomElement }}"{{ end }}></textarea>
		      </div>
		      {{ end }}
		      
		  </form>
		  
		  <div id="controls" class="grid-view">
		      <button class="btn" id="add-property">Add property</button>		      
		      <button class="btn" id="save">Save</button>
		  </div>
		  
	      </div>
	  </div>
	  
      </div>
      
{{ template "browser_footer" }}
{{ end }} 
